# 30-algorithms-in-30-days
<p align="center">
<img width="878" src="50 Algorithms In 50 Days.png" alt="50 Algorithms In 50 Days.png" alt="my banner"> </p>

My take on the idea of "50 Projects in 50 days" except with simple algorithms.<br/><br/>

### RandomGuess - Day 1

This algorithm is a guessing game that generates a random number between 1 and 100 and asks the user to guess it. The program then tells the user if their guess was too high or too low. The algorithm continues to ask the user to guess until they guess the correct number.

### LinearSearch - Day 2

The linear search algorithm is a simple algorithm for finding an element in an array. It works by sequentially checking each element in the array until the element is found or the end of the array is reached. If the element is found, the algorithm returns the index of the element. If the element is not found, the algorithm returns -1.
The linear search algorithm is a very simple algorithm, but it is also very inefficient. The time complexity of the linear search algorithm is O(n), where n is the number of elements in the array. This means that the algorithm will take on average n/2 steps to find an element in the array.
The linear search algorithm is often used as a benchmark for other search algorithms. It is also used in situations where the array is small and the cost of comparing elements is low.

### Insertion Sort - Day 3

The above code implements Insertion Sort Algorithm in Java programming language which sorts elements by taking one at a time from unsorted part, comparing it with all previous sorted elements until its correct position is found where no larger number comes next or if there's already smaller numbers than current then swap them so that they come together properly without any gap between each other.<|im_sep|>

### Selection Sort - Day 4

The Selection Sort algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from unsorted part and putting it at the beginning. The algorithm maintains two subarrays: the left subarray is already sorted, and the right subarray is unsorted. In each iteration, the algorithm finds the minimum element in the unsorted subarray and swaps it with the first element of the unsorted subarray.

### Bubble Sort - Day 5

The Bubble Sort algorithm is a simple sorting algorithm that works by repeatedly comparing adjacent elements in an array and swapping them if they are in the wrong order. The algorithm continues to do this until the array is sorted.
The Bubble Sort algorithm is inefficient for large arrays, but it is still a useful algorithm to learn because it is easy to understand and implement.

### Tree Traversal - Day 6

Tree traversal is an algorithm that visits all the nodes of a tree in a specific order. There are three main types of tree traversal algorithms: inorder, preorder, and postorder.
Inorder traversal visits the left subtree of a node, then the node itself, and then the right subtree. Preorder traversal visits the node itself, then the left subtree, and then the right subtree. Postorder traversal visits the right subtree of a node, then the left subtree, and then the node itself.

### Multiples of 3 and 5 - Day 7

The algorithm you provided is a simple program that sums the multiples of 3 and 5 from 1 to 1000. The program first initializes a variable called `sum` to 0. Then, it uses a for loop to iterate from 0 to 1000. In each iteration, the program checks if the current number is divisible by 3 or 5. If it is, the program adds the number to `sum`. Finally, the program prints the value of `sum` to the console.
The algorithm is simple and efficient. It runs in O(n) time, where n is the number of numbers from 1 to 1000.

### Heap Sort - Day 8


